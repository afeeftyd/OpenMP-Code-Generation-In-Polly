
\section{Insertion Tree Automata}
Tree automata are accepting devices for trees.
Finite tree automata are generalizations of word automata. While a word automaton accepts
a word, a tree automaton accepts a tree. According to the manner in which the automaton 
runs on the input tree, finite tree automata
can be either bottom-up or top-down. A \emph{top-down tree automaton} starts its computation at
the root of the tree and then simultaneously works down the paths of the tree level by level.
The tree automaton accepts the tree if such a run can be defined. A \emph{bottom-up tree automaton}
starts its computation in the leaves of the input tree and works its way up towards the root.
A finite tree automaton can be either deterministic or non-deterministic. This is an important
issue since deterministic top-down automata are strictly less expressive than non-deterministic
top-down automata. For the bottom-up case, deterministic bottom-up tree automata are just
as powerful, from the point of view of language equivalence, as non-deterministic bottom-up
tree automata. Non-deterministic top-down tree automata are equivalent to non-deterministic
bottom-up tree automata.None of the above model is capable of accepting a \emph{non-regular}
tree language unless it consists more than one component.

In \emph{insertion tree automata}, we are trying to combine the features of \emph{fnite tree automata}
and \emph{tree insertion system} so that the resulting machine is capable of accepting both regular
and non-regular tree languages.

\subsection{As Accepting Device}
%\subsection{Language Acceptance}
We can design \emph{tree automata} for accepting trees generated by a \emph{tree insertion system}. 
More interesting thing is that, a tree automata with a single component can accept a non-regular tree language
if we apply insertion operation in the input tree before processing.\\
\begin{example}
        $L_{nr_3} = \{a(b^i(g),c^j(g)),i,j\ge 1,|i-j|\le 2\}$.\\
       A tree automata with a single component cannot
       accept this language. But the  distributed automata, given below, with $3$ components and working in $=1-mode$ is capable of accepting $L_{nr_3}$.\\\\
       $D_1=(K,\Sigma,\{q_f\},\Delta)$, where\\
       $\Sigma = {a,b,c,g}, a\in \Sigma _2, b,c\in \Sigma _1, g\in \Sigma _0$.
\emph{
    \begin{itemize}
              \item Component 1
           \begin{itemize}
            \item $K_1=\{q_b,q_g\}$
            \item $\delta _1 = \{b(q_g)\rightarrow q_b,b(q_b)\rightarrow q_b\}$
           \end{itemize}
        \item Component 2
           \begin{itemize}
            \item $K_2=\{q_g,q_c\}$
            \item $\delta _2 = \{c(q_g)\rightarrow q_c,c(q_c)\rightarrow q_c\}$
           \end{itemize}
        \item Component 3
           \begin{itemize}
            \item $K_3=\{q_b,q_c,q_g,q_f\}$
            \item $\delta _3 = \{g\rightarrow q_g,a(q_b,q_c)\rightarrow q_f\}$
        \end{itemize}
    \end{itemize}
    }
    But if we do some insertion operations, using the \emph{insertion} system given below, in the input tree belongs to $L_{nr_3}$, 
    it will get accepted by a single component tree automata.\\\\\\\\
    $\Gamma_{B _{nr_3}} = (\Sigma,\mathcal{A},\mathcal{A} ',R)$ where,\\
    $\Sigma=\{a_2,b_1,c_1,g_0\}$,   $\mathcal{A}=\{A_1,A_2\}$ ,$\mathcal{A} '=\{A_1\}$\\
{\small $A_1=
    \begin{Bmatrix}    
    \pstree[nodesep=1pt,levelsep=3ex]{\Tr{a}}
        {
            \Tr{b}
            \Tr{c}
        }
\end{Bmatrix}$
        ,
$A_2=
    \begin{Bmatrix} 
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{b}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{c}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{g}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{x}}
        {}
    \end{Bmatrix}$}
\\\\$R=\{B_1,B_2,B_3,B_4,B_5\}$, where\\\\
   $B_1=\{r_1,r_2\}$,  $B_2=\{r_1\}$,  $B_3=\{r2\}$,  $B_4=\{r_1,r_1\}$,  $B_5=\{r_2,r_2\}$\\
   $r_1=(\chi _1, x, arity(b+1))$,  where $\chi _1=(b,\bar x,-)$\\     
   $r_2=(\chi _2, x, arity(c+1))$,  where $\chi _2=(c,\bar x,-)$\\
\\The resultant tree after \emph{insertion} operation will be accepted by the following tree automata with a \emph{single component}.\\\\
    $A_1=(Q,\Sigma,\{q_a\},\Delta)$, where\\
    $Q=\{q_g,q_a,q_b,q_c,q_x\}$,  $\Sigma = \{a,b,c,g,x\}$  and\\
    $\Delta $ contains following rules.\\

\begin{tabular}{llllll}
$g\rightarrow q_g$ & $ x\rightarrow q_x$ & $a(q_b,q_c)\rightarrow q_a$ & 
 \\  $ b(q_g,q_x)\rightarrow q_b$ & $ c(q_g,q_x)\rightarrow q_c$&$b(q_b,q_x)\rightarrow q_b$&$c(q_c,q_x)\rightarrow q_c$
\end{tabular}

\noindent \rule{\textwidth}{1pt}
\end{example}
\begin{example} $L_{nr_4} = \{b(a(b^{2i}(g),c^{2j}(g)),\mbox{ }i,j\ge 1,i=j\mbox{ or } i=j+1\mbox{ or }j=i+1\}$.\\
               A tree automata with a single component cannot accept this language. 
               But the  distributed automata, given below, with $3$ components and working in $=2-mode$ is capable of accepting $L_{nr_4}$.\\\\
       $D_2=(K,\Sigma,\{q_f\},\Delta)$, where\\
       $\Sigma = {a,b,c,g}, a\in \Sigma _2, b,c\in \Sigma _1, g\in \Sigma _0$.
\emph{
    \begin{itemize}
              \item Component 1
           \begin{itemize}
            \item $K_1=\{q_b,q_g\}$
            \item $\delta _1 = \{b(q_g)\rightarrow q_b,b(q_b)\rightarrow q_b\}$
           \end{itemize}
        \item Component 2
           \begin{itemize}
            \item $K_2=\{q_g,q_c\}$
            \item $\delta _2 = \{c(q_g)\rightarrow q_c,c(q_c)\rightarrow q_c\}$
           \end{itemize}
        \item Component 3
           \begin{itemize}
            \item $K_3=\{q_a,q_b,q_c,q_g,q_f\}$
            \item $\delta _3 = \{g\rightarrow q_g,a(q_b,q_c)\rightarrow q_a,b(q_a)\rightarrow q_f\}$
        \end{itemize}
    \end{itemize}
    }
    But if we do some insertion operations, using the \emph{insertion} system given below, in the input tree belongs to $L_{nr_4}$, 
    it will get accepted by a single component tree automata.\\\\
    $\Gamma_{B _{nr_4}} = (\Sigma,\mathcal{A},\mathcal{A} ',R)$ where,\\
    $\Sigma=\{a_2,b_1,c_1,g_0\}$,  $\mathcal{A}=\{A_1,A_2\}$ , $\mathcal{A} '=\{A_1\} $\\
{\small $A=
    \begin{Bmatrix}
        \pstree[nodesep=1pt,levelsep=3ex]{\Tr{b}}
        {
            \pstree[nodesep=1pt,levelsep=3ex]{\Tr{a}}
            {
                \pstree[nodesep=1pt,levelsep=3ex]{\Tr{b}}
                {
                    \Tr{b}
                }
                \pstree[nodesep=1pt,levelsep=3ex]{\Tr{c}}
                {
                    \Tr{c}
                }
            }
        }
    \end{Bmatrix}$
        ,
$A=
\begin{Bmatrix}
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{b}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{c}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{g}}
        {}
        ,
        \pstree[nodesep=1pt,levelsep=6ex]{\Tr{x}}
        {}
    \end{Bmatrix}$}
\\\\$R=\{B_1,B_2,B_3\}$, where\\\\
   $B_1=\{r_1,r_1,r_2,r_2\}$,  $B_2=\{r_1,r_1\}$,  $B_3=\{r_2,r_2\}$\\
   $r_1=(\chi _1, x, arity(b+1))$,  where $\chi _1=(b,\bar x,-)$\\     
   $r_2=(\chi _2, x, arity(c+1))$,  where $\chi _2=(c,\bar x,-)$\\
\\The resultant tree after \emph{insertion} operation will be accepted by the following tree automata with a \emph{single component}.\\\\
    $A_2=(Q,\Sigma,\{q_f\},\Delta)$, where\\
    $Q=\{q_g,q_a,q_b,q_c,q_x,q_f\}$,  $\Sigma = \{a_2,b_1,c_1,g_0,x_0\}$  and\\
    $\Delta $ contains following rules.\\
\begin{tabular}{llllll}
$g\rightarrow q_g$ & $ x\rightarrow q_x$ & $a(q_b,q_c)\rightarrow q_a$ & 
 \\  $ b(q_g,q_x)\rightarrow q_b$ & $ c(q_g,q_x)\rightarrow q_c$&$b(q_b,q_x)\rightarrow q_b$&$c(q_c,q_x)\rightarrow q_c$
\end{tabular}

\noindent \rule{\textwidth}{1pt}
\end{example}
%\emph{\textbf{Claim:} Any tree language which is accepted by a distributed tree automata can be accepted by an insertion tree automata.}



