Title
-----

Implementing libpluto and integrating with Polly

Abstract
--------
PluTo is an autmatic parallelizer and locality optimizer for multicore
architectures. It lacks a library interface which can be used by other
tools like Polly. The proposal aims at implementing libpluto and integrating
it with Polly.

Existing System
---------------

Without having a dedicated library the current Pluto system works as follows

    * The source file is given to Clan(Chunky loop analyzer) to extract polyhedral
      intermediate representation(SCoP) from the source code.
    * The SCoP is converted into internal program representation of Pluto(PlutoProg).
    * The core scheduling algorithm of Pluto(pluto_auto_transform) is applied on
      this and a new schedule is obtained.
    * Perform optional tiling, vectorization and other optimizations.
    * Generate the code using cloog.

Polly makes use of Pluto optimizations with the Pluto version integrated into 
PoCC(Polyhedral Compiler Collection). While building Polly the user need to
download the complete source code of PoCC and compile it. Polly provides
options(-enable-pluto-tile, -enable-pluto-prevector) to get advantage of
Pluto optimizations. Polly internally makes a call to 'pocc' command with the 
corresponding options and with the exported scoplib input file which consists
of the polyhedral discriptions of the SCoPs detected by Polly.

Proposed system
----------------
The key part of Pluto is its core scheduling algorithm. As described above rest
of the part are other tools intergrated into it. So its worth to extract it
out of the tool and implement that as a library. Other users who
need to take advantage of Pluto's scheduling can easily integrate this.

PoCC is too large to be integrated into Polly and LLVM. In addition the current
approach needs the polyhedral representation to be exported to a file. Creating
file for large number of scops may not be scalable and will result in huge overhead.

To use the Pluto optimizations directly in Polly, Pluto needs to be integrated
into Polly as a library(libpluto). I will contribuite to implement libpluto and
integrate this with Polly.

Implementation Plan
-------------------

Phase 1: libpluto implementation
--------------------------------

* Interface design

  The Interface of libpluto should be minimal and simple. This needs to be discussed
  and we have to come up with a suitable interface. A tendative interface can
  be defined as follows.

   * Function name: similar to "pluto_auto_transform"
   * Input        : A single SCoP(essentially only Iteration domain and Dependences).
                    This need to be finalized.
   * Output       : A schedule

//To be checked---
                 |

   * Function name: pluto_tile
   * Input        : Schedule(Output of pluto_auto_transform).
   * Output       : ?

   * Function name: pluto_prevector
   * Input        : Schedule(Output of pluto_auto_transform).
   * Output       : ?

                 |
//To be checked---


Phase 2: Integration with Polly
-------------------------------

* Include libpluto as part of Polly build system.
* Implement a seperate pass(LibPluto.cpp) for performing pluto optimizations which has
    * ScopInfo pass as a prerequisite.
    * Implement the driver functions which convert the ScoP representation
      of Polly into the input representation of libpluto.
    * Implement the driver function which convert the output(schedule) of
      libpluto back to ScoP representation of Polly.
* Create testcases to see the enhanced optimization.
* Compare the result with
* How does libpluto benefit for vectorization ?


Tobias
------
I think an approach similar to the one taken in pocc is good. As far as
I understand the pocc code, the pluto data structures are mainly
untouched and a wrapper function called 'pluto_pocc' implements a nice
scoplib based interface. This has the advantage that for libpluto we can
choose an interface that is more expressive as scoplib and perfectly
matches the requirements of pluto. We can than implement a scoplib
wrapper for this interface and as soon as e.g. openscop is available we
can create a new wrapper to take advantage of the new features of
openscop. This approach also allows that two interfaces coexist, as I
expect there will be a period where we need both scoplib and openscop
interfaces. 

I also like my JSON+isl format as it is extremely convenient to import
into python, to script with it and it already provides the
expressiveness openscop is going to bring us when finished. Yet it is
not a full replacement for scoplib/openscop as it does not provide a
library interface, but it is mainly a file exchange format. I can
imagine to use my JSON/isl format to make the pluto output easily
scriptable. However, as a library format I still plan to have one common
exchange format and hope that openscop is soon available to write an
openscop interface for libpluto.

Louis
-----
imply to standardize the tools, and have a common intermediate representation between the maximum number of tools. I strongly think scoplib (or openscop) is a good way to represent a polyhedral program (and if it's not we should improve it to make it better according to everyone's suggestions). Pluto is a polyhedral tool which needs a polyhedral description of a program as an input and outputs a schedule for it. It is a perfect candidate for the scoplib interface. Everything needed to pluto for the input is already in the scoplib description, and the most important part of the output (the schedule) is also already in the description (with no effort to output the annotations in the option part of the scoplib). So why invent something else if what we have fulfill our needs? In addition, having a single IR between tools simplifies the job of power users or developers who want to create a small pass and also use pluto, but that's another story.

Louis
------

To sum up, my suggestions are as follows:
- have a way to pass the first rows of the schedule.
- have a way to have plutolib compute only one new row of the schedule.
- and indeed there's no need to support the current .fst explicitely in plutolib, this behavior can be emulated. 


Milestones
----------


Experience
----------

If Time Permits
---------------
